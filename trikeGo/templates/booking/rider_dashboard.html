{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rider Dashboard - TrikeGo</title>
    <link rel="stylesheet" href="{% static 'user/css/rider_dashboard.css' %}?v=5" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
</head>
<body>
    <div class="header">
        <h1>Rider Dashboard</h1>
        <a href="{% url 'user:landing' %}" class="logout-btn">Logout</a>
    </div>

    <div id="map"></div>
    <div class="map-legend" id="map-legend-rider" aria-hidden="false">
        <div class="legend-item"><span class="legend-dot driver"></span>Driver</div>
        <div class="legend-item"><span class="legend-dot pickup"></span>Pickup / Rider</div>
        <div class="legend-item"><span class="legend-dot dest"></span>Destination</div>
    </div>

    <div class="container">
        <div class="sidebar">
            <div class="dashboard-profile-card">
                <h2>Welcome, {{ user.first_name }} {{ user.last_name }}!</h2>
                <p>Rider ID: {{ user.username }}</p>
            </div>

            {% if rider_profile %}
            <div class="dashboard-loyaltypoints-card">
                <div class="loyalty-points">
                    <h3>Loyalty Points</h3>
                    <div class="points-number">{{ rider_profile.loyalty_points }}</div>
                    <p>Earn points with every ride!</p>
                </div>
            </div>
            {% endif %}

            <!-- Real-time tracking info -->
            <div class="dashboard-tracking-card" id="tracking-info" style="display:none;">
                <h3>Live Tracking</h3>
                <div id="driver-eta">
                    <p><strong id="eta-label">Time to Pick-up:</strong> <span id="eta-value">Calculating...</span></p>
                    <p><strong>Distance:</strong> <span id="distance-value">--</span></p>
                    <p><strong>Last Updated:</strong> <span id="last-update">--</span></p>
                </div>
                <div class="tracking-status">
                    <div class="status-indicator" id="status-indicator"></div>
                    <span id="tracking-status-text">Driver is on the way</span>
                </div>
            </div>

            <div class="dashboard-activebooks-card">
                <h3>Active Booking</h3>
                {% if active_bookings %}
                    <ul class="booking-list">
                        {% for booking in active_bookings %}
                            <li class="booking-item" data-booking-id="{{ booking.id }}">
                                <strong>{{ booking.pickup_address }}</strong> → {{ booking.destination_address }}<br>
                                <small>Status: <span class="booking-status">{{ booking.get_status_display }}</span></small><br>
                                <small>Booked at: {{ booking.booking_time|date:"M d, Y H:i" }}</small>
                                {% if booking.estimated_arrival %}
                                <br><small>Est. Arrival: {{ booking.estimated_arrival|date:"H:i" }}</small>
                                {% endif %}
                            </li>
                        {% endfor %}
                    </ul>
                {% else %}
                    <p>No active bookings at the moment.</p>
                {% endif %}
            </div>

            <div class="dashboard-quickaction-card">
                <h3>Quick Actions</h3>
                <div class="action-buttons">
                    <a href="#" class="btn btn-primary">Book Ride</a>
                    <a href="#" class="btn btn-secondary">Ride History</a>
                    <a href="#" class="btn btn-success">Payment Methods</a>
                    <a href="#" class="btn btn-warning">Support</a>
                </div>
            </div>
        </div>

        <div class="dashboard-booking-card">
            <h3>Book a Ride</h3>
            <form class="booking-form" method="POST" action="{% url 'user:rider_dashboard' %}">
                {% csrf_token %}
                
                <div class="autocomplete-container">
                    <label for="pickup_location_input">Pickup Location:</label>
                    {{ booking_form.pickup_address }}
                    <div id="pickup-results" class="autocomplete-results"></div>
                    {{ booking_form.pickup_latitude }}
                    {{ booking_form.pickup_longitude }}
                </div>

                <div class="autocomplete-container">
                    <label for="destination_location_input">Destination:</label>
                    {{ booking_form.destination_address }}
                    <div id="destination-results" class="autocomplete-results"></div>
                    {{ booking_form.destination_latitude }}
                    {{ booking_form.destination_longitude }}
                </div>

                <button type="submit" class="btn btn-primary" style="width: 100%;">Find a Trike</button>
            </form>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script>
        const ORS_API_KEY = '{{ settings.OPENROUTESERVICE_API_KEY }}' || '5b3ce3597851110001cf62488c26abeb';
        
        // Real-time tracking variables
        let trackingInterval = null;
        let driverMarker = null;
        let riderMarker = null;
        let pickupMarker = null;
        let destinationMarker = null;
        let driverToRiderRouteLayer = null;
        let riderToDestRouteLayer = null;
        
        class ORSAutocomplete {
            constructor(inputId, resultsId, latFieldId, lonFieldId, onSelectCallback) {
                this.input = document.getElementById(inputId);
                this.results = document.getElementById(resultsId);
                this.latField = document.getElementById(latFieldId);
                this.lonField = document.getElementById(lonFieldId);
                this.onSelectCallback = onSelectCallback;
                this.timeout = null;

                if (!this.input) {
                    console.error(`FAILED to find element with ID: #${inputId}.`);
                    return;
                }
                
                this.init();
            }
            
            init() {
                this.input.addEventListener('input', (e) => this.handleInput(e));
                document.addEventListener('click', (e) => {
                    if (!this.input.contains(e.target) && !this.results.contains(e.target)) {
                        this.results.classList.remove('active');
                    }
                });
            }
            
            handleInput(e) {
                const query = e.target.value.trim();
                clearTimeout(this.timeout);
                
                if (query.length < 3) {
                    this.results.innerHTML = '';
                    this.results.classList.remove('active');
                    return;
                }
                
                this.results.innerHTML = '<div class="loading">Searching...</div>';
                this.results.classList.add('active');
                
                this.timeout = setTimeout(() => this.search(query), 300);
            }
            
            async search(query) {
                try {
                    const params = new URLSearchParams({
                        api_key: ORS_API_KEY,
                        text: query,
                        size: 10,
                        'boundary.country': 'PH'
                    });
                    const url = `https://api.openrouteservice.org/geocode/search?${params.toString()}`;
                    const response = await fetch(url);
                    const data = await response.json();
                    this.displayResults(data.features || []);
                } catch (error) {
                    console.error('Autocomplete API error:', error);
                    this.results.innerHTML = '<div class="loading">Error loading results</div>';
                }
            }
            
            displayResults(features) {
                this.results.innerHTML = '';
                if (features.length === 0) {
                    this.results.innerHTML = '<div class="loading">No results found</div>';
                    return;
                }
                features.forEach(feature => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    const props = feature.properties || {};
                    const name = props.label || props.name || 'Unknown';
                    item.innerHTML = `<strong>${name}</strong>`;
                    item.addEventListener('click', () => this.selectResult(feature));
                    this.results.appendChild(item);
                });
                this.results.classList.add('active');
            }
            
            selectResult(feature) {
                const coords = feature.geometry.coordinates;
                const lat = coords[1];
                const lon = coords[0];
                const props = feature.properties || {};
                this.input.value = props.label || props.name || `${lat}, ${lon}`;
                this.latField.value = lat;
                this.lonField.value = lon;
                this.results.classList.remove('active');
                this.results.innerHTML = '';
                
                if (this.onSelectCallback) {
                    this.onSelectCallback(lat, lon);
                }
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const map = L.map('map').setView([14.5995, 120.9842], 12); // fallback Manila
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);

            // Default to user's current GPS if available
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (pos) => {
                        const { latitude, longitude } = pos.coords;
                        map.setView([latitude, longitude], 15);
                        if (!riderMarker) {
                            const riderIcon = L.divIcon({ className: 'rider-marker', html: '<div class="marker-inner"></div>', iconSize: [24, 24] });
                            riderMarker = L.marker([latitude, longitude], { icon: riderIcon }).addTo(map).bindPopup('Your location');
                        }
                    },
                    () => {},
                    { enableHighAccuracy: true, timeout: 5000 }
                );
            }

            let activeInput = null;

            const pickupInput = document.getElementById('pickup_location_input');
            const destInput = document.getElementById('destination_location_input');

            function updateMapMarker(markerRef, lat, lon, icon) {
                if (markerRef && markerRef.setLatLng) {
                    markerRef.setLatLng([lat, lon]);
                    return markerRef;
                }
                return L.marker([lat, lon], { icon }).addTo(map);
            }

            const riderIcon = L.divIcon({ className: 'rider-marker', html: '<div class="marker-inner"></div>', iconSize: [24, 24] });
            const driverIcon = L.divIcon({ className: 'driver-marker', html: '<div class="marker-inner"></div>', iconSize: [28, 28] });
            const pickupIcon = L.divIcon({ className: 'pickup-marker', html: '<div class="marker-inner"></div>', iconSize: [20, 20] });
            const destIcon = L.divIcon({ className: 'dest-marker', html: '<div class="marker-inner"></div>', iconSize: [20, 20] });

            function updateMapAndMarker(lat, lon) {
                map.setView([lat, lon], 16);
                if (activeInput === 'pickup') {
                    pickupMarker = updateMapMarker(pickupMarker, lat, lon, pickupIcon);
                } else if (activeInput === 'destination') {
                    destinationMarker = updateMapMarker(destinationMarker, lat, lon, destIcon);
                }
            }

            new ORSAutocomplete('pickup_location_input', 'pickup-results', 'id_pickup_latitude', 'id_pickup_longitude', updateMapAndMarker);
            new ORSAutocomplete('destination_location_input', 'destination-results', 'id_destination_latitude', 'id_destination_longitude', updateMapAndMarker);

            pickupInput.addEventListener('focus', () => activeInput = 'pickup');
            destInput.addEventListener('focus', () => activeInput = 'destination');

            map.on('click', async (e) => {
                if (!activeInput) return;

                const { lat, lng } = e.latlng;
                updateMapAndMarker(lat, lng);

                try {
                    const params = new URLSearchParams({
                        api_key: ORS_API_KEY,
                        'point.lat': lat,
                        'point.lon': lng,
                        size: 1
                    });
                    const url = `https://api.openrouteservice.org/geocode/reverse?${params.toString()}`;
                    const response = await fetch(url);
                    const data = await response.json();

                    if (data.features && data.features.length > 0) {
                        const props = data.features[0].properties || {};
                        const address = props.label || props.name || `${lat}, ${lng}`;
                        if (activeInput === 'pickup') {
                            pickupInput.value = address;
                            document.getElementById('id_pickup_latitude').value = lat;
                            document.getElementById('id_pickup_longitude').value = lng;
                        } else if (activeInput === 'destination') {
                            destInput.value = address;
                            document.getElementById('id_destination_latitude').value = lat;
                            document.getElementById('id_destination_longitude').value = lng;
                        }
                    }
                } catch (error) {
                    console.error("Reverse geocoding error:", error);
                }
            });

            // Real-time tracking functionality with two-route view
            const activeBookingItems = document.querySelectorAll('.booking-item');
            if (activeBookingItems.length > 0) {
                // Find the first booking that is not pending
                let target = null;
                activeBookingItems.forEach((el) => {
                    const statusText = (el.querySelector('.booking-status')?.textContent || '').trim();
                    if (statusText && statusText.toLowerCase() !== 'pending driver assignment' && target === null) {
                        target = el;
                    }
                });
                if (!target) {
                    // fallback to first item
                    target = activeBookingItems[0];
                }
                const bookingId = target.dataset.bookingId;
                const bookingStatus = (target.querySelector('.booking-status')?.textContent || '').trim();
                if (bookingId && bookingStatus.toLowerCase() !== 'pending driver assignment') {
                    startTracking(bookingId, map);
                }
            }
        });

        async function startTracking(bookingId, map) {
            document.getElementById('tracking-info').style.display = 'block';
            await updateAll(bookingId, map);
            trackingInterval = setInterval(async () => {
                await updateAll(bookingId, map);
            }, 5000);
        }

        async function updateAll(bookingId, map) {
            try {
                const infoRes = await fetch(`/api/booking/${bookingId}/route_info/`);
                if (!infoRes.ok) {
                    console.error('Failed to fetch route info:', infoRes.status);
                    return;
                }
                const info = await infoRes.json();
                if (info.status !== 'success') {
                    console.error('Route info error:', info.message);
                    return;
                }
                
                console.log('Route info received:', info);
                
                // Coerce all coordinates to numbers and validate
                const dLat = Number(info.driver_lat);
                const dLon = Number(info.driver_lon);
                const rLat = Number(info.rider_lat);
                const rLon = Number(info.rider_lon);
                const pLat = Number(info.pickup_lat);
                const pLon = Number(info.pickup_lon);
                const xLat = Number(info.destination_lat);
                const xLon = Number(info.destination_lon);
                
                console.log('Coordinates:', { dLat, dLon, rLat, rLon, pLat, pLon, xLat, xLon });
                
                const hasDriver = Number.isFinite(dLat) && Number.isFinite(dLon);
                const hasPickup = Number.isFinite(pLat) && Number.isFinite(pLon);
                const hasDest = Number.isFinite(xLat) && Number.isFinite(xLon);
                const hasRider = Number.isFinite(rLat) && Number.isFinite(rLon);
                
                console.log('Coordinate validation:', { hasDriver, hasPickup, hasDest, hasRider });
                
                // Update markers
                if (hasDriver) {
                    const driverLatLng = [dLat, dLon];
                    if (!driverMarker) {
                        const driverIcon = L.divIcon({
                            className: 'driver-marker',
                            html: '<div style="background: #28a745; width: 28px; height: 28px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);"></div>',
                            iconSize: [28, 28]
                        });
                        driverMarker = L.marker(driverLatLng, { icon: driverIcon }).addTo(map).bindPopup('Driver');
                    } else {
                        driverMarker.setLatLng(driverLatLng);
                    }
                }
                
                if (hasRider) {
                    const riderLatLng = [rLat, rLon];
                    if (!riderMarker) {
                        const riderIcon = L.divIcon({
                            className: 'rider-marker',
                            html: '<div style="background: #ffc107; width: 24px; height: 24px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);"></div>',
                            iconSize: [24, 24]
                        });
                        riderMarker = L.marker(riderLatLng, { icon: riderIcon }).addTo(map).bindPopup('You');
                    } else {
                        riderMarker.setLatLng(riderLatLng);
                    }
                }
                
                if (hasPickup) {
                    const pickupLatLng = [pLat, pLon];
                    if (!pickupMarker) {
                        const pickupIcon = L.divIcon({
                            className: 'pickup-marker',
                            html: '<div style="background: #ffc107; width: 20px; height: 20px; border-radius: 50%; border: 2px solid white;"></div>',
                            iconSize: [20, 20]
                        });
                        pickupMarker = L.marker(pickupLatLng, { icon: pickupIcon }).addTo(map).bindPopup('Pickup');
                    } else {
                        pickupMarker.setLatLng(pickupLatLng);
                    }
                }
                
                if (hasDest) {
                    const destLatLng = [xLat, xLon];
                    if (!destinationMarker) {
                        const destIcon = L.divIcon({
                            className: 'dest-marker',
                            html: '<div style="background: #007bff; width: 20px; height: 20px; border-radius: 50%; border: 2px solid white;"></div>',
                            iconSize: [20, 20]
                        });
                        destinationMarker = L.marker(destLatLng, { icon: destIcon }).addTo(map).bindPopup('Destination');
                    } else {
                        destinationMarker.setLatLng(destLatLng);
                    }
                }

                // Build route requests only if inputs exist
                let dtData = null, rdData = null;
                if (hasDriver && hasPickup) {
                    console.log('Fetching driver to pickup route...');
                    const dtUrl = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=${ORS_API_KEY}&start=${dLon},${dLat}&end=${pLon},${pLat}`;
                    const dtRes = await fetch(dtUrl);
                    dtData = await dtRes.json();
                    console.log('Driver to pickup route:', dtData);
                }
                if (hasPickup && hasDest) {
                    console.log('Fetching pickup to destination route...');
                    const rdUrl = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=${ORS_API_KEY}&start=${pLon},${pLat}&end=${xLon},${xLat}`;
                    const rdRes = await fetch(rdUrl);
                    rdData = await rdRes.json();
                    console.log('Pickup to destination route:', rdData);
                }

                // Remove old routes
                if (driverToRiderRouteLayer) map.removeLayer(driverToRiderRouteLayer);
                if (riderToDestRouteLayer) map.removeLayer(riderToDestRouteLayer);

                // Add new routes
                if (dtData && dtData.features && dtData.features.length > 0) {
                    driverToRiderRouteLayer = L.geoJSON(dtData.features[0], {
                        style: { color: '#28a745', weight: 5, opacity: 0.8 }
                    }).addTo(map);
                    console.log('Added driver to pickup route');
                }
                if (rdData && rdData.features && rdData.features.length > 0) {
                    riderToDestRouteLayer = L.geoJSON(rdData.features[0], {
                        style: { color: '#007bff', weight: 5, opacity: 0.8 }
                    }).addTo(map);
                    console.log('Added pickup to destination route');
                }

                // Fit map to show all routes
                const layers = [];
                if (driverToRiderRouteLayer) layers.push(driverToRiderRouteLayer);
                if (riderToDestRouteLayer) layers.push(riderToDestRouteLayer);
                if (layers.length > 0) {
                    let bounds = layers[0].getBounds();
                    layers.forEach(l => bounds.extend(l.getBounds()));
                    map.fitBounds(bounds, { padding: [50, 50] });
                }

                // Update ETA and distance
                const etaLabel = document.getElementById('eta-label');
                const etaValue = document.getElementById('eta-value');
                const distanceValue = document.getElementById('distance-value');
                
                let etaMin = null, distKm = null;

                if ((info.booking_status === 'accepted' || info.booking_status === 'on_the_way') && dtData && dtData.features?.[0]?.properties?.segments?.[0]) {
                    etaLabel.textContent = 'Time to Pick-up:';
                    const seg = dtData.features[0].properties.segments[0];
                    etaMin = Math.ceil(seg.duration / 60);
                    distKm = (seg.distance / 1000).toFixed(2);
                    console.log('ETA updated - Time to Pick-up:', etaMin, 'min');
                } else if (info.booking_status === 'started' && rdData && rdData.features?.[0]?.properties?.segments?.[0]) {
                    etaLabel.textContent = 'Time to Destination:';
                    const seg = rdData.features[0].properties.segments[0];
                    etaMin = Math.ceil(seg.duration / 60);
                    distKm = (seg.distance / 1000).toFixed(2);
                    console.log('ETA updated - Time to Destination:', etaMin, 'min');
                } else if (dtData && dtData.features?.[0]?.properties?.segments?.[0]) {
                    // Fallback: if status missing, prefer driver->pickup ETA
                    etaLabel.textContent = 'Time to Pick-up:';
                    const seg = dtData.features[0].properties.segments[0];
                    etaMin = Math.ceil(seg.duration / 60);
                    distKm = (seg.distance / 1000).toFixed(2);
                    console.log('ETA updated - Fallback to Pick-up:', etaMin, 'min');
                } else if (rdData && rdData.features?.[0]?.properties?.segments?.[0]) {
                    etaLabel.textContent = 'Time to Destination:';
                    const seg = rdData.features[0].properties.segments[0];
                    etaMin = Math.ceil(seg.duration / 60);
                    distKm = (seg.distance / 1000).toFixed(2);
                    console.log('ETA updated - Fallback to Destination:', etaMin, 'min');
                }

                if (etaMin != null) etaValue.textContent = `${etaMin} min`;
                if (distKm != null) distanceValue.textContent = `${distKm} km`;

                const updateTime = new Date();
                document.getElementById('last-update').textContent = updateTime.toLocaleTimeString();
                const indicator = document.getElementById('status-indicator');
                indicator.style.backgroundColor = '#28a745';
                indicator.classList.add('pulse');
            } catch (e) {
                console.error('Tracking error', e);
                document.getElementById('status-indicator').style.backgroundColor = '#dc3545';
            }
        }

        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        window.addEventListener('beforeunload', () => {
            if (trackingInterval) {
                clearInterval(trackingInterval);
            }
        });
    </script>

</body>
</html>