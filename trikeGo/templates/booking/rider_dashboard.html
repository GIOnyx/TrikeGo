{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rider Dashboard - TrikeGo</title>
    <link rel="stylesheet" href="{% static 'user/css/rider_dashboard.css' %}?v=5" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
</head>
<body>
    <div class="header">
        <h1>Rider Dashboard</h1>
        <a href="{% url 'user:landing' %}" class="logout-btn">Logout</a>
    </div>

    <div id="map"></div>
    <div class="map-legend" id="map-legend-rider" aria-hidden="false">
        <div class="legend-item"><span class="legend-dot driver"></span>Driver</div>
        <div class="legend-item"><span class="legend-dot pickup"></span>Pickup / Rider</div>
        <div class="legend-item"><span class="legend-dot dest"></span>Destination</div>
    </div>

    <div class="container">
        <div class="sidebar" aria-expanded="false">
            <div class="nav-bar">
                <div class="nav-top">
                    <div class="brand">TrikeGo</div>
                </div>
                <div class="nav-icons">
                    <a class="nav-icon" title="Profile" href="#">
                        <img src="{% static 'user/images/account_icon.png' %}" alt="Profile">
                    </a>
                    <a class="nav-icon" title="Rides" href="#">
                        <img src="{% static 'user/images/tricycle_icon.png' %}" alt="Rides">
                    </a>
                    <a class="nav-icon" title="Payments" href="#">
                        <img src="{% static 'user/images/card_icon.png' %}" alt="Payments">
                    </a>
                    <a class="nav-icon" title="Support" href="#">
                        <img src="{% static 'user/images/support_icon.png' %}" alt="Support">
                    </a>
                </div>
            </div>

            <div class="sidebar-content">
            <div class="dashboard-profile-card">
                <h2>Welcome, {{ user.first_name }} {{ user.last_name }}!</h2>
                <p>Rider ID: {{ user.username }}</p>
            </div>

            {% if rider_profile %}
            <div class="dashboard-loyaltypoints-card">
                <div class="loyalty-points">
                    <h3>Loyalty Points</h3>
                    <div class="points-number">{{ rider_profile.loyalty_points }}</div>
                    <p>Earn points with every ride!</p>
                </div>
            </div>
            {% endif %}

            <!-- Real-time tracking info -->
            <div class="dashboard-tracking-card" id="tracking-info" style="display:none;">
                <h3>Live Tracking</h3>
                <div id="driver-eta">
                    <p><strong id="eta-label">Time to Pick-up:</strong> <span id="eta-value">Calculating...</span></p>
                    <p><strong>Distance:</strong> <span id="distance-value">--</span></p>
                    <p><strong>Last Updated:</strong> <span id="last-update">--</span></p>
                </div>
                <div class="tracking-status">
                    <div class="status-indicator" id="status-indicator"></div>
                    <span id="tracking-status-text">Driver is on the way</span>
                </div>
            </div>

            <div class="dashboard-activebooks-card">
                <h3>Active Booking</h3>
                {% if active_bookings %}
                    <ul class="booking-list">
                        {% for booking in active_bookings %}
                            <li class="booking-item" data-booking-id="{{ booking.id }}" {% if booking.driver %}data-booking-driver="{{ booking.driver.id }}"{% endif %}>
                                <strong>{{ booking.pickup_address }}</strong> → {{ booking.destination_address }}<br>
                                <small>Status: <span class="booking-status">{{ booking.get_status_display }}</span></small><br>
                                <small>Booked at: {{ booking.booking_time|date:"M d, Y H:i" }}</small>
                                {% if booking.estimated_arrival %}
                                <br><small>Est. Arrival: {{ booking.estimated_arrival|date:"H:i" }}</small>
                                {% endif %}
                                {% if booking.status == 'pending' %}
                                <form method="POST" action="{% url 'user:cancel_booking' booking.id %}" style="display:inline;margin-top:8px;">
                                    {% csrf_token %}
                                    <button type="submit" class="btn btn-danger small" >Cancel Booking</button>
                                </form>
                                {% endif %}
                            </li>
                        {% endfor %}
                    </ul>
                {% else %}
                    <p>No active bookings at the moment.</p>
                {% endif %}
            </div>

            <div class="dashboard-quickaction-card">
                <h3>Quick Actions</h3>
                <div class="action-buttons">
                    <a href="#" class="btn btn-primary">Book Ride</a>
                    <a href="#" class="btn btn-secondary">Ride History</a>
                    <a href="#" class="btn btn-success">Payment Methods</a>
                    <a href="#" class="btn btn-warning">Support</a>
                </div>
            </div>
            </div>
        </div>

        <div class="dashboard-booking-card">
            <h3>Book a Ride</h3>
            <form class="booking-form" method="POST" action="{% url 'user:rider_dashboard' %}">
                {% csrf_token %}
                
                <div class="autocomplete-container">
                    <label for="pickup_location_input">Pickup Location:</label>
                    {{ booking_form.pickup_address }}
                    <div id="pickup-results" class="autocomplete-results"></div>
                    {{ booking_form.pickup_latitude }}
                    {{ booking_form.pickup_longitude }}
                </div>

                <div class="autocomplete-container">
                    <label for="destination_location_input">Destination:</label>
                    {{ booking_form.destination_address }}
                    <div id="destination-results" class="autocomplete-results"></div>
                    {{ booking_form.destination_latitude }}
                    {{ booking_form.destination_longitude }}
                </div>

                <button type="submit" class="btn btn-primary" style="width: 100%;">Find a Trike</button>
            </form>
        </div>
    </div>

    <!-- Driver info card shown when a booking is accepted -->
    <div id="driver-info-card" class="driver-info-card" style="display:none;" aria-hidden="true">
        <div class="driver-card-inner">
            <div class="driver-avatar"></div>
            <div class="driver-details">
                <div class="driver-name">Driver Name</div>
                <div class="driver-meta">
                    <span class="driver-plate">Plate: -</span>
                    <span class="driver-color">Color: -</span>
                </div>
                <div class="driver-fare">Fare: PHP100</div>

                <!-- Extra info: ETA, pickup and destination shown in the card -->
                <div class="driver-info-extra">
                    <div class="info-eta"><strong>ETA:</strong> <span id="card-eta">--</span></div>
                    <div class="info-pickup"><strong>Pickup:</strong> <span id="card-pickup">--</span></div>
                    <div class="info-destination"><strong>Destination:</strong> <span id="card-dest">--</span></div>
                </div>
            </div>
            <div class="driver-actions">
                <button id="msg-driver-btn" class="btn btn-primary">Chat</button>
            </div>
        </div>
    </div>

    <!-- Booking preview card: shows booking summary even if no driver has accepted yet -->
    <div id="booking-preview-card" class="driver-info-card" style="display:none;" aria-hidden="true">
        <div class="driver-card-inner">
            <div class="driver-details">
                <div class="driver-name">Booking Preview</div>
                <div class="driver-meta">
                    <div><strong>Pickup:</strong> <span id="preview-pickup">--</span></div>
                    <div><strong>Destination:</strong> <span id="preview-dest">--</span></div>
                </div>
                <div class="driver-fare">Estimated Fare: <span id="preview-fare">--</span></div>
            </div>
            <div class="driver-actions">
                <form method="POST" id="preview-cancel-form" action="#">
                    {% csrf_token %}
                    <button id="preview-cancel-btn" type="submit" class="btn btn-danger" style="color: #fff;">Cancel Booking</button>
                </form>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script>
        const ORS_API_KEY = '{{ settings.OPENROUTESERVICE_API_KEY }}' || '5b3ce3597851110001cf62488c26abeb';
        
    // Real-time tracking variables
    let trackingInterval = null;
    let driverMarker = null;
    let pickupMarker = null;
    let destinationMarker = null;
    let driverToRiderRouteLayer = null;
    let riderToDestRouteLayer = null;
        
        class ORSAutocomplete {
            constructor(inputId, resultsId, latFieldId, lonFieldId, onSelectCallback) {
                this.input = document.getElementById(inputId);
                this.results = document.getElementById(resultsId);
                this.latField = document.getElementById(latFieldId);
                this.lonField = document.getElementById(lonFieldId);
                this.onSelectCallback = onSelectCallback;
                this.timeout = null;

                if (!this.input) {
                    console.error(`FAILED to find element with ID: #${inputId}.`);
                    return;
                }
                
                this.init();
            }
            
            init() {
                this.input.addEventListener('input', (e) => this.handleInput(e));
                document.addEventListener('click', (e) => {
                    if (!this.input.contains(e.target) && !this.results.contains(e.target)) {
                        this.results.classList.remove('active');
                    }
                });
            }
            
            handleInput(e) {
                const query = e.target.value.trim();
                clearTimeout(this.timeout);
                
                if (query.length < 3) {
                    this.results.innerHTML = '';
                    this.results.classList.remove('active');
                    return;
                }
                
                this.results.innerHTML = '<div class="loading">Searching...</div>';
                this.results.classList.add('active');
                
                this.timeout = setTimeout(() => this.search(query), 300);
            }
            
            async search(query) {
                try {
                    const params = new URLSearchParams({
                        api_key: ORS_API_KEY,
                        text: query,
                        size: 10,
                        'boundary.country': 'PH'
                    });
                    const url = `https://api.openrouteservice.org/geocode/search?${params.toString()}`;
                    const response = await fetch(url);
                    const data = await response.json();
                    let features = data.features || [];
                    // If map center is available, compute distance for each feature and sort by proximity
                    try {
                        const center = map.getCenter();
                        features.forEach(f => {
                            const [lon, lat] = f.geometry.coordinates;
                            const d = map.distance(center, L.latLng(lat, lon));
                            f.__distance = d; // meters
                        });
                        features.sort((a, b) => (a.__distance || 0) - (b.__distance || 0));
                    } catch (err) {
                        // map may not be initialized; ignore
                    }
                    this.displayResults(features);
                } catch (error) {
                    console.error('Autocomplete API error:', error);
                    this.results.innerHTML = '<div class="loading">Error loading results</div>';
                }
            }
            
            displayResults(features) {
                this.results.innerHTML = '';
                if (features.length === 0) {
                    this.results.innerHTML = '<div class="loading">No results found</div>';
                    return;
                }
                features.forEach(feature => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    const props = feature.properties || {};
                    const name = props.label || props.name || 'Unknown';
                    let distanceText = '';
                    if (feature.__distance != null) {
                        const meters = Math.round(feature.__distance);
                        distanceText = ` <small style="color:#999;margin-left:8px;">(${meters}m)</small>`;
                    }
                    item.innerHTML = `<strong>${name}</strong>${distanceText}`;
                    item.addEventListener('click', () => this.selectResult(feature));
                    this.results.appendChild(item);
                });
                this.results.classList.add('active');
            }
            
            selectResult(feature) {
                const coords = feature.geometry.coordinates;
                const lat = coords[1];
                const lon = coords[0];
                const props = feature.properties || {};
                this.input.value = props.label || props.name || `${lat}, ${lon}`;
                this.latField.value = lat;
                this.lonField.value = lon;
                this.results.classList.remove('active');
                this.results.innerHTML = '';
                
                if (this.onSelectCallback) {
                    this.onSelectCallback(lat, lon);
                }
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const map = L.map('map').setView([14.5995, 120.9842], 12); // fallback Manila
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);

            // Default to user's current GPS if available - do not create a separate rider marker (simplified UI)
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (pos) => {
                        const { latitude, longitude } = pos.coords;
                        map.setView([latitude, longitude], 15);
                        // intentionally do not add a rider marker; only driver/pickup/destination are shown
                    },
                    () => {},
                    { enableHighAccuracy: true, timeout: 5000 }
                );
            }

            let activeInput = null;

            const pickupInput = document.getElementById('pickup_location_input');
            const destInput = document.getElementById('destination_location_input');

            function updateMapMarker(markerRef, lat, lon, icon) {
                if (markerRef && markerRef.setLatLng) {
                    markerRef.setLatLng([lat, lon]);
                    return markerRef;
                }
                return L.marker([lat, lon], { icon }).addTo(map);
            }

            const riderIcon = L.divIcon({ className: 'rider-marker', html: '<div class="marker-inner"></div>', iconSize: [24, 24] });
            const driverIcon = L.divIcon({ className: 'driver-marker', html: '<div class="marker-inner"></div>', iconSize: [28, 28] });
            const pickupIcon = L.divIcon({ className: 'pickup-marker', html: '<div class="marker-inner"></div>', iconSize: [20, 20] });
            const destIcon = L.divIcon({ className: 'dest-marker', html: '<div class="marker-inner"></div>', iconSize: [20, 20] });

            function updateMapAndMarker(lat, lon) {
                map.setView([lat, lon], 16);
                if (activeInput === 'pickup') {
                    pickupMarker = updateMapMarker(pickupMarker, lat, lon, pickupIcon);
                } else if (activeInput === 'destination') {
                    destinationMarker = updateMapMarker(destinationMarker, lat, lon, destIcon);
                }
            }

            new ORSAutocomplete('pickup_location_input', 'pickup-results', 'id_pickup_latitude', 'id_pickup_longitude', updateMapAndMarker);
            new ORSAutocomplete('destination_location_input', 'destination-results', 'id_destination_latitude', 'id_destination_longitude', updateMapAndMarker);

            pickupInput.addEventListener('focus', () => activeInput = 'pickup');
            destInput.addEventListener('focus', () => activeInput = 'destination');

            // If the rider already has a booking (any .booking-item present), hide the Book a Ride panel.
            // This enforces "one booking at a time" on the client UI immediately.
            const anyBookingEl = document.querySelector('.booking-item');
            if (anyBookingEl) {
                document.body.classList.add('booking-active');
            }

            // Booking preview: show a preview card for the first pending booking (no driver assigned yet)
            const bookingItems = document.querySelectorAll('.booking-item');
            if (bookingItems.length > 0) {
                let previewBooking = null;
                bookingItems.forEach(el => {
                    const status = (el.querySelector('.booking-status')?.textContent || '').trim().toLowerCase();
                    // only consider pending bookings (no driver assigned yet)
                    if (!previewBooking && (status === 'pending' || status === 'pending driver assignment' || !el.dataset.bookingDriver)) {
                        // ensure we don't pick bookings that are already accepted/on the way/started
                        if (['accepted', 'on_the_way', 'started'].includes(status)) return;
                        previewBooking = el;
                    }
                });

                if (previewBooking) {
                    const bookingId = previewBooking.dataset.bookingId;
                    const pickupText = previewBooking.querySelector('strong')?.textContent?.trim() || '--';
                    const destText = previewBooking.childNodes[2]?.textContent?.trim() || '--';

                    const previewCard = document.getElementById('booking-preview-card');
                    document.getElementById('preview-pickup').textContent = pickupText;
                    document.getElementById('preview-dest').textContent = destText;
                    // Simple fare estimate based on distance could be calculated server-side; show placeholder
                    document.getElementById('preview-fare').textContent = 'Estimating...';

                    // Wire cancel form action to the cancel endpoint for this booking
                    const previewForm = document.getElementById('preview-cancel-form');
                    previewForm.action = `{% url 'user:cancel_booking' 0 %}`.replace('/0/', `/${bookingId}/`);

                    previewCard.style.display = 'block';
                    previewCard.setAttribute('aria-hidden', 'false');
                    // Render a preview route (pickup -> destination) immediately for pending bookings
                    // updateAll will fetch route_info and draw the pickup->destination route when available
                    try {
                        // don't start real-time tracking for preview — just draw the route once
                        updateAll(bookingId, map);
                    } catch (err) {
                        console.warn('Failed to render booking preview route', err);
                    }
                    // hide booking panel to avoid duplicate booking when preview exists
                    document.body.classList.add('booking-active');
                    // As a fallback, directly hide the booking card element in case CSS isn't applied (cache/ordering)
                    try {
                        const bookingPanel = document.querySelector('.dashboard-booking-card');
                        if (bookingPanel) bookingPanel.style.display = 'none';
                    } catch (err) {
                        console.warn('Could not hide booking panel element directly', err);
                    }
                }
            }

            map.on('click', async (e) => {
                if (!activeInput) return;

                const { lat, lng } = e.latlng;
                updateMapAndMarker(lat, lng);

                try {
                    const params = new URLSearchParams({
                        api_key: ORS_API_KEY,
                        'point.lat': lat,
                        'point.lon': lng,
                        size: 1
                    });
                    const url = `https://api.openrouteservice.org/geocode/reverse?${params.toString()}`;
                    const response = await fetch(url);
                    const data = await response.json();

                    if (data.features && data.features.length > 0) {
                        const props = data.features[0].properties || {};
                        const address = props.label || props.name || `${lat}, ${lng}`;
                        if (activeInput === 'pickup') {
                            pickupInput.value = address;
                            document.getElementById('id_pickup_latitude').value = lat;
                            document.getElementById('id_pickup_longitude').value = lng;
                        } else if (activeInput === 'destination') {
                            destInput.value = address;
                            document.getElementById('id_destination_latitude').value = lat;
                            document.getElementById('id_destination_longitude').value = lng;
                        }
                    }
                } catch (error) {
                    console.error("Reverse geocoding error:", error);
                }
            });

            // Real-time tracking functionality with two-route view
            const activeBookingItems = document.querySelectorAll('.booking-item');
            if (activeBookingItems.length > 0) {
                // Find the first booking that is not pending
                let target = null;
                activeBookingItems.forEach((el) => {
                    const statusText = (el.querySelector('.booking-status')?.textContent || '').trim();
                    if (statusText && statusText.toLowerCase() !== 'pending driver assignment' && target === null) {
                        target = el;
                    }
                });
                if (!target) {
                    // fallback to first item
                    target = activeBookingItems[0];
                }
                const bookingId = target.dataset.bookingId;
                const bookingStatus = (target.querySelector('.booking-status')?.textContent || '').trim();
                if (bookingId && bookingStatus.toLowerCase() !== 'pending driver assignment') {
                    startTracking(bookingId, map);
                }
            }
        });

        async function startTracking(bookingId, map) {
            document.getElementById('tracking-info').style.display = 'block';
            await updateAll(bookingId, map);
            trackingInterval = setInterval(async () => {
                await updateAll(bookingId, map);
            }, 5000);
        }

        async function updateAll(bookingId, map) {
            try {
                const infoRes = await fetch(`/api/booking/${bookingId}/route_info/`);
                if (!infoRes.ok) {
                    console.error('Failed to fetch route info:', infoRes.status);
                    return;
                }
                const info = await infoRes.json();
                if (info.status !== 'success') {
                    console.error('Route info error:', info.message);
                    return;
                }
                
                console.log('Route info received:', info);
                
                // Coerce all coordinates to numbers and validate
                const dLat = Number(info.driver_lat);
                const dLon = Number(info.driver_lon);
                const rLat = Number(info.rider_lat);
                const rLon = Number(info.rider_lon);
                const pLat = Number(info.pickup_lat);
                const pLon = Number(info.pickup_lon);
                const xLat = Number(info.destination_lat);
                const xLon = Number(info.destination_lon);
                
                console.log('Coordinates:', { dLat, dLon, rLat, rLon, pLat, pLon, xLat, xLon });
                
                const hasDriver = Number.isFinite(dLat) && Number.isFinite(dLon);
                const hasPickup = Number.isFinite(pLat) && Number.isFinite(pLon);
                const hasDest = Number.isFinite(xLat) && Number.isFinite(xLon);
                const hasRider = Number.isFinite(rLat) && Number.isFinite(rLon);
                
                console.log('Coordinate validation:', { hasDriver, hasPickup, hasDest, hasRider });
                
                // Update markers
                if (hasDriver) {
                    const driverLatLng = [dLat, dLon];
                    if (!driverMarker) {
                        const driverIcon = L.divIcon({
                            className: 'driver-marker',
                            html: '<div style="background: #28a745; width: 28px; height: 28px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);"></div>',
                            iconSize: [28, 28]
                        });
                        driverMarker = L.marker(driverLatLng, { icon: driverIcon }).addTo(map).bindPopup('Driver');
                    } else {
                        driverMarker.setLatLng(driverLatLng);
                    }
                }
                
                // We intentionally do not show a rider location marker to simplify the UI.
                
                if (hasPickup) {
                    const pickupLatLng = [pLat, pLon];
                    if (!pickupMarker) {
                        const pickupIcon = L.divIcon({
                            className: 'pickup-marker',
                            html: '<div style="background: #ffc107; width: 20px; height: 20px; border-radius: 50%; border: 2px solid white;"></div>',
                            iconSize: [20, 20]
                        });
                        pickupMarker = L.marker(pickupLatLng, { icon: pickupIcon }).addTo(map).bindPopup('Pickup');
                    } else {
                        pickupMarker.setLatLng(pickupLatLng);
                    }
                }
                
                if (hasDest) {
                    const destLatLng = [xLat, xLon];
                    if (!destinationMarker) {
                        const destIcon = L.divIcon({
                            className: 'dest-marker',
                            html: '<div style="background: #007bff; width: 20px; height: 20px; border-radius: 50%; border: 2px solid white;"></div>',
                            iconSize: [20, 20]
                        });
                        destinationMarker = L.marker(destLatLng, { icon: destIcon }).addTo(map).bindPopup('Destination');
                    } else {
                        destinationMarker.setLatLng(destLatLng);
                    }
                }

                // Build route requests. Prefer server-provided payload for preview (when no driver)
                let dtData = null, rdData = null;
                // If the API returned a 'route_payload' (server-side calculated pickup->destination),
                // use that to draw the preview route when no driver exists yet.
                if (info.route_payload && !hasDriver) {
                    try {
                        rdData = info.route_payload.route_data;
                        console.log('Using server-provided pickup->destination route payload');
                    } catch (err) {
                        console.warn('Invalid route_payload format', err);
                    }
                } else {
                    if (hasDriver && hasPickup) {
                        console.log('Fetching driver to pickup route...');
                        const dtUrl = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=${ORS_API_KEY}&start=${dLon},${dLat}&end=${pLon},${pLat}`;
                        const dtRes = await fetch(dtUrl);
                        dtData = await dtRes.json();
                        console.log('Driver to pickup route:', dtData);
                    }
                    if (hasPickup && hasDest) {
                        console.log('Fetching pickup to destination route...');
                        const rdUrl = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=${ORS_API_KEY}&start=${pLon},${pLat}&end=${xLon},${xLat}`;
                        const rdRes = await fetch(rdUrl);
                        rdData = await rdRes.json();
                        console.log('Pickup to destination route:', rdData);
                    }
                }

                // Remove old routes
                if (driverToRiderRouteLayer) map.removeLayer(driverToRiderRouteLayer);
                if (riderToDestRouteLayer) map.removeLayer(riderToDestRouteLayer);

                // Add new routes
                if (dtData && dtData.features && dtData.features.length > 0) {
                    driverToRiderRouteLayer = L.geoJSON(dtData.features[0], {
                        style: { color: '#28a745', weight: 5, opacity: 0.8 }
                    }).addTo(map);
                    console.log('Added driver to pickup route');
                }
                if (rdData && rdData.features && rdData.features.length > 0) {
                    riderToDestRouteLayer = L.geoJSON(rdData.features[0], {
                        style: { color: '#007bff', weight: 5, opacity: 0.8 }
                    }).addTo(map);
                    console.log('Added pickup to destination route');
                }

                // Fit map to show all routes
                const layers = [];
                if (driverToRiderRouteLayer) layers.push(driverToRiderRouteLayer);
                if (riderToDestRouteLayer) layers.push(riderToDestRouteLayer);
                if (layers.length > 0) {
                    let bounds = layers[0].getBounds();
                    layers.forEach(l => bounds.extend(l.getBounds()));
                    map.fitBounds(bounds, { padding: [50, 50] });
                }

                // Update ETA and distance
                const etaLabel = document.getElementById('eta-label');
                const etaValue = document.getElementById('eta-value');
                const distanceValue = document.getElementById('distance-value');
                
                let etaMin = null, distKm = null;

                if ((info.booking_status === 'accepted' || info.booking_status === 'on_the_way') && dtData && dtData.features?.[0]?.properties?.segments?.[0]) {
                    etaLabel.textContent = 'Time to Pick-up:';
                    const seg = dtData.features[0].properties.segments[0];
                    etaMin = Math.ceil(seg.duration / 60);
                    distKm = (seg.distance / 1000).toFixed(2);
                    console.log('ETA updated - Time to Pick-up:', etaMin, 'min');
                } else if (info.booking_status === 'started' && rdData && rdData.features?.[0]?.properties?.segments?.[0]) {
                    etaLabel.textContent = 'Time to Destination:';
                    const seg = rdData.features[0].properties.segments[0];
                    etaMin = Math.ceil(seg.duration / 60);
                    distKm = (seg.distance / 1000).toFixed(2);
                    console.log('ETA updated - Time to Destination:', etaMin, 'min');
                } else if (dtData && dtData.features?.[0]?.properties?.segments?.[0]) {
                    // Fallback: if status missing, prefer driver->pickup ETA
                    etaLabel.textContent = 'Time to Pick-up:';
                    const seg = dtData.features[0].properties.segments[0];
                    etaMin = Math.ceil(seg.duration / 60);
                    distKm = (seg.distance / 1000).toFixed(2);
                    console.log('ETA updated - Fallback to Pick-up:', etaMin, 'min');
                } else if (rdData && rdData.features?.[0]?.properties?.segments?.[0]) {
                    etaLabel.textContent = 'Time to Destination:';
                    const seg = rdData.features[0].properties.segments[0];
                    etaMin = Math.ceil(seg.duration / 60);
                    distKm = (seg.distance / 1000).toFixed(2);
                    console.log('ETA updated - Fallback to Destination:', etaMin, 'min');
                }

                if (etaMin != null) etaValue.textContent = `${etaMin} min`;
                if (distKm != null) distanceValue.textContent = `${distKm} km`;

                const updateTime = new Date();
                document.getElementById('last-update').textContent = updateTime.toLocaleTimeString();
                const indicator = document.getElementById('status-indicator');
                indicator.style.backgroundColor = '#28a745';
                indicator.classList.add('pulse');

                // Show driver info card when booking is accepted or on the way
                try {
                    const infoCard = document.getElementById('driver-info-card');
                    const shouldShow = (info.booking_status === 'accepted' || info.booking_status === 'on_the_way' || info.booking_status === 'started');

                    // Toggle body class so the booking panel is hidden when a booking is active
                    if (shouldShow) {
                        document.body.classList.add('booking-active');
                    } else {
                        document.body.classList.remove('booking-active');
                    }

                    if (shouldShow) {
                        const driverObj = info.driver || null;
                        const driverName = (driverObj && driverObj.name) ? driverObj.name : (info.driver_name || info.driver_full_name || 'Driver');
                        const tricycle = info.tricycle || {};
                        const driverPlate = (driverObj && driverObj.plate) ? driverObj.plate : (info.driver_plate || tricycle.plate_number || info.plate_number || 'AB 1234');
                        const driverColor = tricycle.color || info.driver_color || info.color || (driverObj && driverObj.color) || 'Red';
                        const tricycleImage = tricycle.image_url || info.tricycle_image_url || info.image_url || null;

                        infoCard.querySelector('.driver-name').textContent = driverName;
                        infoCard.querySelector('.driver-plate').textContent = `Plate: ${driverPlate}`;
                        infoCard.querySelector('.driver-color').textContent = `Color: ${driverColor}`;
                        infoCard.querySelector('.driver-fare').textContent = `Fare: PHP100`;

                        // Set avatar image if available
                        const avatar = infoCard.querySelector('.driver-avatar');
                        if (tricycleImage) {
                            avatar.style.backgroundImage = `url('${tricycleImage}')`;
                            avatar.style.backgroundSize = 'cover';
                            avatar.style.backgroundPosition = 'center';
                        } else {
                            avatar.style.backgroundImage = '';
                        }

                        // Populate ETA / pickup / destination into the card
                        const cardEta = document.getElementById('card-eta');
                        const cardPickup = document.getElementById('card-pickup');
                        const cardDest = document.getElementById('card-dest');
                        cardEta.textContent = (etaMin != null) ? `${etaMin} min` : '--';
                        // Use human-friendly pickup/destination if present in the booking list on the sidebar, else fall back to coordinates
                        const sidebarBookingEl = document.querySelector('.booking-item[data-booking-id]');
                        if (sidebarBookingEl) {
                            const pickupText = sidebarBookingEl.querySelector('strong')?.textContent?.trim() || `${pLat.toFixed(5)}, ${pLon.toFixed(5)}`;
                            const destText = sidebarBookingEl.childNodes[2]?.textContent?.trim() || `${xLat.toFixed(5)}, ${xLon.toFixed(5)}`;
                            cardPickup.textContent = pickupText;
                            // destText may include arrow and other text; ensure we only include the destination address
                            cardDest.textContent = destText;
                        } else {
                            cardPickup.textContent = `${pLat.toFixed(5)}, ${pLon.toFixed(5)}`;
                            cardDest.textContent = `${xLat.toFixed(5)}, ${xLon.toFixed(5)}`;
                        }
                        // Show distances provided by server if available
                        try {
                            if (info.pickup_to_destination_km != null) {
                                const previewFare = document.getElementById('preview-fare');
                                previewFare.textContent = `${info.pickup_to_destination_km} km`;
                            }
                            if (info.driver_to_pickup_km != null) {
                                const distanceValue = document.getElementById('distance-value');
                                distanceValue.textContent = `${info.driver_to_pickup_km} km`;
                            }
                        } catch (e) {
                            // ignore
                        }
                        infoCard.style.display = 'block';
                        infoCard.setAttribute('aria-hidden', 'false');
                    } else {
                        infoCard.style.display = 'none';
                        infoCard.setAttribute('aria-hidden', 'true');
                    }
                    // Ensure booking panel visibility follows bookingAccepted state
                    try {
                        const bookingPanel = document.querySelector('.dashboard-booking-card');
                        if (bookingPanel) {
                            if (bookingAccepted) {
                                bookingPanel.style.display = 'none';
                            } else {
                                // remove inline style to allow CSS to manage display
                                bookingPanel.style.display = '';
                            }
                        }
                    } catch (err) {
                        console.warn('Could not toggle booking panel display', err);
                    }
                    // If booking has been accepted or is on the way, hide the booking preview card
                    const previewCard = document.getElementById('booking-preview-card');
                    const bookingAccepted = (info.booking_status === 'accepted' || info.booking_status === 'on_the_way' || info.booking_status === 'started');
                    if (previewCard) {
                        if (bookingAccepted) {
                            previewCard.style.display = 'none';
                            previewCard.setAttribute('aria-hidden', 'true');
                        }
                    }
                } catch (err) {
                    console.warn('Driver info card update failed', err);
                }
            } catch (e) {
                console.error('Tracking error', e);
                document.getElementById('status-indicator').style.backgroundColor = '#dc3545';
            }
        }

        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        window.addEventListener('beforeunload', () => {
            if (trackingInterval) {
                clearInterval(trackingInterval);
            }
        });
    </script>

</body>
</html>